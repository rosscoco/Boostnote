createdAt: "2018-10-11T18:10:21.017Z"
updatedAt: "2018-10-11T19:38:21.630Z"
type: "MARKDOWN_NOTE"
folder: "3a8b178644eb697aa42c"
title: "Further GROUP BY"
content: '''
  ## Further GROUP BY 
  
  Implicit/Explicit Grouping
  
  In the below query we are applying an aggregate function to every result being returned which will *implicitly* create a grouping for that clause
  * Further explained - EVERY value returned is generated by an aggregate query. Each aggregate functions is creating a single result, adding up to a single row.  This has created an **implicit grouping**
  * An aggregate function creates a GROUP. Only having GROUPS in your query means they can be combined without further input from you
  
  ```sql
  SELECT MAX(avail_balance) max_balance,
  -> MIN(avail_balance) min_balance,
  -> AVG(avail_balance) avg_balance,
  -> SUM(avail_balance) tot_balance,
  -> COUNT(*) num_accounts
  -> FROM account
  -> WHERE product_cd = 'CHK';
  ``````
  
  | max_balance | min_balance | avg_balance | tot_balance | num_accounts |
  |:--|:--|:--|:--|:--|:--
  | 38552.05 | 122.37 | 7300.800985 | 73008.01 | 10 |
  
  This would fail if we tried to select a non aggregated value as well.  Attempting to select another value such as 
  
  ```sql
  SELECT product_cd, 
  MAX(avail_balance) max_balance {....}
  ```
  
  Would tell you that you cannot mix GROUP columns with a non-GROUP column if there is no GROUP BY clause.
  	-Would selecting the product code of the average balance of all accounts make sense? No as there would be multiple product codes returned for those accounts.
  	
  Instead add the GROUP BY clause to create an **explicit grouping**
  
  ```sql
  SELECT product_cd,
  	MAX(avail_balance) max_balance,
  	MIN(avail_balance) min_balance,
  	AVG(avail_balance) avg_balance,
  	SUM(avail_balance) tot_balance,
  	COUNT(*) num_accts
  FROM account
  GROUP BY product_cd;
  ```
  
  | product_cd | max_balance | min_balance | avg_balance | tot_balance | num_accts |
  |:--|:--|:--|:--|:--|:--
  | BUS | 9345.55 | 0.00 | 4672.774902 | 9345.55 | 2 |
  | CD | 10000.00 | 1500.00 | 4875.000000 | 19500.00 | 4 |
  | CHK | 38552.05 | 122.37 | 7300.800985 | 73008.01 | 10 |
  | MM | 9345.55 | 2212.50 | 5681.713216 | 17045.14 | 3 |
  | SAV | 767.77 | 200.00 | 463.940002 | 1855.76 | 4 |
  | SBL | 50000.00 | 50000.00 | 50000.000000 | 50000.00 | 1 |
  
  
  ### Multi column Grouping
  
  a GROUP can span more than one column.  Adding multiple columns to a GROUP BY clause will create distinct entries for eavery unique combination of those groups
  
  ```sql
  SELECT product_cd, open_branch_id,
  	SUM(avail_balance) tot_balance
  	FROM account
  	GROUP BY product_cd, open_branch_id;
  ```
  | product_cd | open_branch_id | tot_balance |
  |:--|:--|:--
  | BUS | 2 | 9345.55 |
  | BUS | 4 | 0.00 |
  | CD | 1 | 11500.00 |
  | CD | 2 | 8000.00 |
  
  Above you have a new grouping for each combination of the product code and branch id
  
  ### Filter using HAVING
  
  Aggregate functions are calculated after any WHERE clauses have executed so if you want to filter the aggregated data further you must use HAVING after the GROUP BY clause.
  
  HAVING clauses will filter out groups ** using only on other aggregate functions **
  * These do not have to be the ones used in the SELECT clause.  
  * 	They *can* be aliased in the SELECT clause or 
  
  
  ### Super aggregate WITH ROLLUP
  
  WITH ROLLUP is a GROUP BY modifier that will create an aggregate ( basically the sum ) of a specified groups  output.
  * Below we will add a ROLLUP to the product id and we will be shown the sum of all product_id GROUP values in a new row.  The product id will be NULL as this is the sum of all product ids*
  
  Modify the above multi column group so that the last line is 
  
  ```sql
  GROUP BY product_cd, open_branch_id WITH ROLLUP
  ```
  
  | product_cd | open_branch_id | tot_balance |
  |:--|:--|:--
  | BUS | 2 | 9345.55 |
  | BUS | 4 | 0.00 |
  | BUS | NULL | 9345.55 |
  | CD | 1 | 11500.00 |
  | CD | 2 | 8000.00 |
  | CD | NULL | 19500 |
  
  
  
  ### Ordering Results
  
  You cannot order by an aggregate functions results by name but you can order by a specific column number
'''
tags: []
isStarred: false
isTrashed: false
